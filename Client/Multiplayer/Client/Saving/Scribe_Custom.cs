using Multiplayer.Common;
using System;
using System.Collections.Generic;
using UnityEngine;
using Verse;

namespace Multiplayer.Client.Saving
{
    public static class Scribe_Custom
    {
        public static void LookValue<T>(T t, string label, bool force = false)
        {
            Scribe_Values.Look(ref t, label, forceSave: force);
        }

        public static void LookDeep<T>(T t, string label)
        {
            Scribe_Deep.Look(ref t, label);
        }

        public static void LookULong(ref ulong value, string label, ulong defaultValue = 0)
        {
            string valueStr = value.ToString();
            Scribe_Values.Look(ref valueStr, label, defaultValue.ToString());
            if (Scribe.mode == LoadSaveMode.LoadingVars)
                ulong.TryParse(valueStr, out value);
        }

        public static void LookRect(ref Rect rect, string label)
        {
            Vector4 value = new Vector4(rect.x, rect.y, rect.width, rect.height);
            Scribe_Values.Look(ref value, label);
            rect = new Rect(value.x, value.y, value.z, value.w);
        }

        public static void LookIdBlock(ref IdBlock block, string label)
        {
            if (Scribe.mode == LoadSaveMode.Saving && block != null)
            {
                string base64 = Convert.ToBase64String(block.Serialize());
                Scribe_Values.Look(ref base64, label);
            }

            if (Scribe.mode == LoadSaveMode.LoadingVars)
            {
                string base64 = null;
                Scribe_Values.Look(ref base64, label);

                if (base64 != null)
                    block = IdBlock.Deserialize(new ByteReader(Convert.FromBase64String(base64)));
                else
                    block = null;
            }
        }

        public static void LookRecord<T>(ref T record)
        {

        }

        // Copy of RimWorld's method but with ctor args
        public static void LookValueDeep<K, V>(ref Dictionary<K, V> dict, string label, params object[] valueCtorArgs)
        {
            List<K> keysWorkingList = null;
            List<V> valuesWorkingList = null;

            if (Scribe.EnterNode(label))
            {
                try
                {
                    if (Scribe.mode == LoadSaveMode.Saving || Scribe.mode == LoadSaveMode.LoadingVars)
                    {
                        keysWorkingList = new List<K>();
                        valuesWorkingList = new List<V>();
                    }

                    if (Scribe.mode == LoadSaveMode.Saving)
                    {
                        foreach (KeyValuePair<K, V> current in dict)
                        {
                            keysWorkingList.Add(current.Key);
                            valuesWorkingList.Add(current.Value);
                        }
                    }

                    Scribe_Collections.Look(ref keysWorkingList, "keys", LookMode.Value);
                    Scribe_Collections.Look(ref valuesWorkingList, "values", LookMode.Deep, valueCtorArgs);

                    if (Scribe.mode == LoadSaveMode.Saving)
                    {
                        if (keysWorkingList != null)
                        {
                            keysWorkingList.Clear();
                            keysWorkingList = null;
                        }

                        if (valuesWorkingList != null)
                        {
                            valuesWorkingList.Clear();
                            valuesWorkingList = null;
                        }
                    }

                    if (Scribe.mode == LoadSaveMode.LoadingVars)
                    {
                        dict.Clear();
                        if (keysWorkingList == null)
                        {
                            Log.Error("Cannot fill dictionary because there are no keys.");
                        }
                        else if (valuesWorkingList == null)
                        {
                            Log.Error("Cannot fill dictionary because there are no values.");
                        }
                        else
                        {
                            if (keysWorkingList.Count != valuesWorkingList.Count)
                            {
                                Log.Error(string.Concat(new object[]
                                {
                                    "Keys count does not match the values count while loading a dictionary (maybe keys and values were resolved during different passes?). Some elements will be skipped. keys=",
                                    keysWorkingList.Count,
                                    ", values=",
                                    valuesWorkingList.Count
                                }));
                            }

                            int num = Math.Min(keysWorkingList.Count, valuesWorkingList.Count);
                            for (int i = 0; i < num; i++)
                            {
                                if (keysWorkingList[i] == null)
                                {
                                    Log.Error(string.Concat(new object[]
                                    {
                                        "Null key while loading dictionary of ",
                                        typeof(K),
                                        " and ",
                                        typeof(V),
                                        "."
                                    }));
                                }
                                else
                                {
                                    try
                                    {
                                        dict.Add(keysWorkingList[i], valuesWorkingList[i]);
                                    }
                                    catch (Exception ex)
                                    {
                                        Log.Error(string.Concat(new object[]
                                        {
                                            "Exception in LookDictionary(node=",
                                            label,
                                            "): ",
                                            ex
                                        }));
                                    }
                                }
                            }
                        }
                    }

                    if (Scribe.mode == LoadSaveMode.PostLoadInit)
                    {
                        if (keysWorkingList != null)
                        {
                            keysWorkingList.Clear();
                            keysWorkingList = null;
                        }

                        if (valuesWorkingList != null)
                        {
                            valuesWorkingList.Clear();
                            valuesWorkingList = null;
                        }
                    }
                }
                finally
                {
                    Scribe.ExitNode();
                }
            }
            else if (Scribe.mode == LoadSaveMode.LoadingVars)
            {
                dict = null;
            }
        }
    }
}
